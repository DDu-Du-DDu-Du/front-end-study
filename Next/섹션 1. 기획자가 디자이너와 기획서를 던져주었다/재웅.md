## 📚 Next 프로젝트 구조

1. npx create-next-app@latest
2. `public` : 모든 사람이 접속할 수 있는 폴더. 중요한 데이터를 처리할 땐 주의해야 한다.
3. `src` : 타입스크립트 코드 폴더
   - `app` : 라우팅을 담당하는 파일들로 구성

<br/>

## 📚 레이아웃 (Layout)

1. `Page.tsx`를 children으로 포함하고 있는 파일이다. 최상위에 존재할 경우 RootLayout이 되며, 모든 하위 페이지 컴포넌트들에 영향을 미친다.
2. 만약 하위 페이지만의 Layout이 존재한다면, RootLayout - Layout - Page의 형태로 계층구조가 형성된다.
3. 기본적으로 페이지 이동이 발생하는 경우 레이아웃은 리렌더링이 이루어지지 않는다. 리렌더링을 원하는 경우 레이아웃이 아닌 **템플릿**(`template.tsx`)을 이용하면 된다.
4. 페이지별 Context Provider라고 볼 수 있을까?

<br/>

## 📚 페이지 구조와 라우트 그룹

1. app 내부에 폴더를 만들어 페이지 구조를 계층화할 수 있고, `[]`를 감싸 동적 라우팅을 구현할 수 있다.
2. `()`를 감싸 라우트를 그룹으로 관리할 수 있다. 실제 URL 라우팅에는 영향을 주지 않는다.
3. **레이아웃 기준으로 그룹핑**하는 것을 권장한다.

![Untitled](/Next/섹션%201.%20기획자가%20디자이너와%20기획서를%20던져주었다/Image_Jaewoong/스크린샷%201.png)

로그인 전, 후를 기준으로 라우팅 페이지를 그룹지어주었다.

<br/>

## 📚 페러렐 라우트 (Parallel Route)

1. 페이지 위에 또다른 페이지를 모달 형태로 얹고 싶은 경우 페러렐 라우트를 사용한다.
2. `@폴더명`을 통해 라우트 폴더를 생성할 수 있다.
3. 동일한 depth에 존재하는 page나 layout만 적용가능하다.
4. default.tsx를 통해 페러렐 라우트의 기본값을 지정해줄 수 있다. 보통 null을 반환하게 한다.
5. 모달을 중첩해서 불러오고 싶다면 같은 형태의 페러렐 라우트를 생성하고, 레이아웃에서 불러와 늘려주면 된다.
6. 유저 페이지에서도, 로그인 여부에 따라 렌더링할 섹션을 유저 페이지 레이아웃에서 관리할 수 있다.

![Untitled](/Next/섹션%201.%20기획자가%20디자이너와%20기획서를%20던져주었다/Image_Jaewoong/스크린샷%202.png)

![Untitled](/Next/섹션%201.%20기획자가%20디자이너와%20기획서를%20던져주었다/Image_Jaewoong/스크린샷%203.png)

🤔 그니까 지금 두 페이지가 같은 URL을 바라보고 있는데, 하나는 페러렐라우트(`@modal`)이기 때문에 그 위에 렌더링된건가? 근데 아래 `i/flow/login` 페이지가 아닌 `/` 페이지를 띄우고 싶어서 인터셉팅 라우트를 적용하는거고..?

### ✏️ default.tsx [🔗ref](https://nextjs.org/docs/app/api-reference/file-conventions/default)

1. 접근한 URL에 페러렐 라우트 섹션이 없는 경우, 기본으로 보여줄 값을 관리할 수 있는 파일이다.
2. 최상위에서는 사용할 경우 NotFound로 빠지지 않고, default를 보여주기 때문에, 페러렐 라우트와 함께만 사용되는 게 좋을 듯..?

<br/>

## 📚 인터셉팅 라우트 (Intercepting Route)

1. modal은 `i/flow/login` 경로에 있는 페이지를 렌더링하고, 밑에 깔리는 페이지는 `/` 경로에 있는 페이지를 컴포넌트를 렌더링하고 싶을 때
2. 인터셉팅을 원하는 폴더 앞에 `(.)`를 붙혀주면 되며, 실제 라우팅에는 영향을 주지 않는다.
3. 정리하면, `i/flow/login` 경로에 있는 페이지를 `@modal/(.)i/flow/login` 에 있는 페이지가 가로채게 된다!
4. 그럼 **가로채기 당한 페이지**는 사용될 일이 없는 것 아닌가?
   - 해당 URL에서 **새로고침**한 경우, 원래 페이지가 렌더링된다.
   - 새로고침했을 때도 페러렐 라우트를 유지할 순 없나?

<br/>

### Private 폴더

1. `_폴더명`으로 생성할 수 있다. 폴더나 컴포넌트 정리용이라고 보면 된다.

<br/>

### 로그인 모달 리다이렉트 시 루트 페이지가 날아가는 문제

1. 서버 사이드에서 redirect가 실행된 것이 원인으로, useRouter 훅을 이용해 `/login`에 접근할 경우 `/i/flow/login`으로 replace시켜준다.
2. `push`가 아닌 `replace` 시켜주는 이유는 `/login`을 생략하기 때문에 뒤로가기 시 redirect-loop에 빠지는 것을 막아주기 때문이다.

<br/>

## 💭 생각해보기

1. 프로젝트의 전체적인 에러 처리를 페러렐 - 인터셉팅을 이용해 관리할 수 없을까?

- 아래처럼 에러가 발생하면 동일한 깊이의 에러 디렉토리로 리다이렉트, 그 에러 디렉토리를 에러 모달이 인터셉팅
- 에러코드를 동적 파라미터로 넘겨줘서, 공용 컴포넌트로 만들어 모듈처럼 관리할 수 있을 듯

<br/>

```
// url : /log/record/(...)error/[code]/page.tsx

const page = ({ code }) => {
   return <ErrorModal code={code}
}
```
